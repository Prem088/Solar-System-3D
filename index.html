<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>3D Solar System with Speed Controls</title>
    <style>
        /* Basic body and canvas styling */
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }

        canvas {
            display: block;
        }

        /* Tooltip styling */
        #tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            pointer-events: none;
            font-family: Arial, sans-serif;
            font-size: 12px;
            display: none;
            z-index: 100;
        }

        /* Control panel styles */
        #control-panel {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            max-width: 250px;
            font-family: Arial, sans-serif;
            overflow-y: auto;
            max-height: 90vh;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        /* Dark mode styles for control panel */
        body.dark #control-panel {
            background: rgba(30, 30, 30, 0.9);
            color: white;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        /* Button style */
        button {
            margin-top: 10px;
            width: 100%;
            padding: 6px;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            font-family: Arial, sans-serif;
        }

        button:hover {
            background-color: #ddd;
        }

        body.dark button:hover {
            background-color: #444;
        }
    </style>
</head>

<body>

    <!-- Control Panel Container -->
    <div id="control-panel">
        <h3>Planet Orbit Speed Control</h3>
    </div>

    <!-- Tooltip for planet names -->
    <div id="tooltip"></div>

    <!-- Include Three.js library -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <script>
        // ------------------- Scene Setup -------------------

        // Create the scene object
        const scene = new THREE.Scene();

        // Setup camera with perspective view
        const camera = new THREE.PerspectiveCamera(
            45, // Field of View in degrees
            window.innerWidth / window.innerHeight, // Aspect ratio
            0.1, // Near clipping plane
            1000 // Far clipping plane
        );
        camera.position.set(0, 30, 60); // Position camera slightly above and back
        camera.lookAt(0, 0, 0); // Look at the center (sun)

        // Create the WebGL renderer and attach it to document
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Clock to handle delta time for smooth animation
        const clock = new THREE.Clock();

        // ------------------ Lighting Setup -------------------

        // Point light to simulate sunlight at the center (sun)
        const sunlight = new THREE.PointLight(0xffffff, 2, 200);
        sunlight.position.set(0, 0, 0);
        scene.add(sunlight);

        // Ambient light to soften shadows and illuminate dark sides
        const ambientLight = new THREE.AmbientLight(0x222222);
        scene.add(ambientLight);

        // ------------------ Create the Sun --------------------

        // Geometry and material for the sun sphere
        const sunGeometry = new THREE.SphereGeometry(4, 64, 64);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);

        // ------------------ Background Stars ------------------

        // Function to create many small points randomly positioned as stars
        function createStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 1000;
            const positions = [];

            for (let i = 0; i < starCount; i++) {
                // Random position in a large cube around scene
                positions.push(
                    (Math.random() - 0.5) * 600,
                    (Math.random() - 0.5) * 600,
                    (Math.random() - 0.5) * 600
                );
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7 });

            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }
        createStars();

        // ------------------ Planet Data and Creation -----------

        // Data for each planet: size, color, orbit distance, orbit speed, rotation speed
        const planetData = [
            { name: 'Mercury', size: 0.5, color: 0xaaaaaa, distance: 7, orbitSpeed: 0.04, rotationSpeed: 0.02 },
            { name: 'Venus', size: 0.7, color: 0xffa500, distance: 10, orbitSpeed: 0.035, rotationSpeed: 0.015 },
            { name: 'Earth', size: 0.8, color: 0x0000ff, distance: 13, orbitSpeed: 0.03, rotationSpeed: 0.02 },
            { name: 'Mars', size: 0.6, color: 0xff0000, distance: 16, orbitSpeed: 0.025, rotationSpeed: 0.018 },
            { name: 'Jupiter', size: 1.5, color: 0xffd700, distance: 22, orbitSpeed: 0.02, rotationSpeed: 0.04 },
            { name: 'Saturn', size: 1.3, color: 0xd2b48c, distance: 27, orbitSpeed: 0.017, rotationSpeed: 0.038 },
            { name: 'Uranus', size: 1.1, color: 0x40e0d0, distance: 32, orbitSpeed: 0.014, rotationSpeed: 0.03 },
            { name: 'Neptune', size: 1, color: 0x00008b, distance: 37, orbitSpeed: 0.012, rotationSpeed: 0.028 },
        ];

        const planets = [];

        // Create planets meshes, assign userData for orbiting and rotation
        planetData.forEach(data => {
            const geometry = new THREE.SphereGeometry(data.size, 32, 32);
            const material = new THREE.MeshStandardMaterial({ color: data.color });
            const mesh = new THREE.Mesh(geometry, material);

            // Store orbit parameters in userData
            mesh.userData = {
                distance: data.distance,
                orbitSpeed: data.orbitSpeed,
                rotationSpeed: data.rotationSpeed,
                angle: Math.random() * Math.PI * 2, // Random start position in orbit
                name: data.name
            };

            scene.add(mesh);
            planets.push(mesh);
        });

        // ------------------ Control Panel Setup ----------------

        // Reference control panel div
        const controlPanel = document.getElementById('control-panel');

        // Create sliders to control each planet's orbit speed dynamically
        planetData.forEach((planet, index) => {
            const planetControl = document.createElement('div');
            planetControl.style.marginBottom = '10px';

            // Label for slider
            const label = document.createElement('label');
            label.htmlFor = `slider-${index}`;
            label.textContent = `${planet.name} Speed: `;
            label.style.display = 'block';
            label.style.fontWeight = 'bold';

            // Slider input element
            const slider = document.createElement('input');
            slider.type = 'range';
            slider.min = '0';
            slider.max = '0.1';
            slider.step = '0.001';
            slider.value = planet.orbitSpeed;
            slider.id = `slider-${index}`;
            slider.style.width = '100%';

            // Display current speed value next to slider
            const speedValue = document.createElement('span');
            speedValue.textContent = slider.value;

            // Update planet orbit speed and displayed value on slider change
            slider.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                planets[index].userData.orbitSpeed = val;
                speedValue.textContent = val.toFixed(3);
            });

            // Append elements to control panel
            planetControl.appendChild(label);
            planetControl.appendChild(slider);
            planetControl.appendChild(speedValue);

            controlPanel.appendChild(planetControl);
        });

        // ----------- Pause / Resume Animation Button -------------

        // Create pause/resume button
        const pauseBtn = document.createElement('button');
        pauseBtn.textContent = 'Pause Animation';
        controlPanel.appendChild(pauseBtn);

        // Track animation state
        let isPaused = false;
        pauseBtn.addEventListener('click', () => {
            isPaused = !isPaused;
            pauseBtn.textContent = isPaused ? 'Resume Animation' : 'Pause Animation';
        });

        // ----------- Dark / Light Mode Toggle Button -------------

        // Create dark/light toggle button
        const darkToggleBtn = document.createElement('button');
        darkToggleBtn.textContent = 'Toggle Dark/Light Mode';
        controlPanel.appendChild(darkToggleBtn);

        // Toggle body dark mode class on click
        darkToggleBtn.addEventListener('click', () => {
            document.body.classList.toggle('dark');
            // Change background accordingly
            if (document.body.classList.contains('dark')) {
                renderer.setClearColor(0x000000); // Black background for dark mode
            } else {
                renderer.setClearColor(0xdddddd); // Light grey background for light mode
            }
        });

        // Initialize background color for renderer (black for dark mode)
        renderer.setClearColor(0x000000);

        // ----------- Tooltip for Hovering Planets ----------------

        const raycaster = new THREE.Raycaster(); // For detecting mouse over objects
        const mouse = new THREE.Vector2();       // Store normalized mouse coordinates
        const tooltip = document.getElementById('tooltip');

        // Update mouse variable on mouse move
        window.addEventListener('mousemove', (event) => {
            // Normalize mouse coordinates (-1 to +1) for both axes
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            // Position tooltip near mouse
            tooltip.style.left = (event.clientX + 10) + 'px';
            tooltip.style.top = (event.clientY + 10) + 'px';
        });

        // ----------- Camera Controls: Zoom and Click-to-Move --------

        // Variables for camera zoom and pan
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        // Zoom control via mouse wheel
        window.addEventListener('wheel', (event) => {
            // Adjust camera distance on zoom in/out with limits
            camera.position.z += event.deltaY * 0.05;
            camera.position.z = THREE.MathUtils.clamp(camera.position.z, 20, 100);
        });

        // Start dragging on mouse down
        renderer.domElement.addEventListener('mousedown', (event) => {
            isDragging = true;
            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        });

        // End dragging on mouse up
        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Update camera angle on dragging mouse (orbit around sun)
        renderer.domElement.addEventListener('mousemove', (event) => {
            if (!isDragging) return;

            const deltaX = (event.clientX - previousMousePosition.x) * 0.005;
            const deltaY = (event.clientY - previousMousePosition.y) * 0.005;

            // Rotate camera around the sun (Y axis)
            camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), -deltaX);

            // Vertical rotation clamp (avoid flipping)
            const maxPolarAngle = Math.PI / 2 - 0.1;
            const minPolarAngle = 0.1;

            // Compute current polar angle of camera in spherical coordinates
            const camVector = camera.position.clone().sub(new THREE.Vector3(0, 0, 0));
            let polarAngle = Math.acos(camVector.y / camVector.length());

            // Adjust polar angle by deltaY but clamp
            polarAngle += deltaY;
            polarAngle = THREE.MathUtils.clamp(polarAngle, minPolarAngle, maxPolarAngle);

            // Update camera Y position based on new polar angle, keeping radius constant
            const radius = camVector.length();
            camera.position.y = radius * Math.cos(polarAngle);
            const horizontalRadius = radius * Math.sin(polarAngle);

            // Update X and Z while preserving azimuthal angle (horizontal angle)
            const azimuthalAngle = Math.atan2(camVector.z, camVector.x);
            camera.position.x = horizontalRadius * Math.cos(azimuthalAngle);
            camera.position.z = horizontalRadius * Math.sin(azimuthalAngle);

            camera.lookAt(0, 0, 0);

            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        });

        // ------------------ Animation Loop ------------------------

        function animate() {
            requestAnimationFrame(animate);

            // If paused, skip updates
            if (!isPaused) {
                const delta = clock.getDelta();

                // Slowly rotate the sun on its own axis
                sun.rotation.y += 0.005;

                // Update planet orbits and rotations
                planets.forEach(planet => {
                    // Update orbit angle based on speed and delta time (scaled for consistency)
                    planet.userData.angle += planet.userData.orbitSpeed * delta * 60;
                    // Calculate new position on orbit circle in XZ plane
                    planet.position.set(
                        Math.cos(planet.userData.angle) * planet.userData.distance,
                        0,
                        Math.sin(planet.userData.angle) * planet.userData.distance
                    );
                    // Rotate planet on its own axis
                    planet.rotation.y += planet.userData.rotationSpeed * delta * 60;
                });
            }

            // Raycast from camera through mouse position to detect hovered planet
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(planets);

            if (intersects.length > 0) {
                // Show tooltip with planet name when hovered
                tooltip.style.display = 'block';
                tooltip.textContent = intersects[0].object.userData.name;
            } else {
                // Hide tooltip if no planet hovered
                tooltip.style.display = 'none';
            }

            // Render the scene from camera viewpoint
            renderer.render(scene, camera);
        }

        animate();

        // ------------------ Window Resize Handling -----------------

        window.addEventListener('resize', () => {
            // Update camera aspect ratio and renderer size to match new window size
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>

</body>

</html>